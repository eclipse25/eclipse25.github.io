---
layout: post
title: "[운영체제] 프로세스와 스레드"
categories: [0.4 운영체제]
tags: [OS]
---

## 프로세스

- **프로세스**: 메모리에 적재되어 지금 실행중인 프로그램
- 작업 관리자에서 볼 수 있듯 동시에(사용자가 눈치채지 못하도록 빠르게 번갈아가며) 실행되는 프로세스는 매우 많다.
- 다양한 프로세스들을 관리하고 실행한다.
- 프로세스와 스레드, 프로세스 동기화, 교착상태 해결 등을 수행한다.

### 종류

- **포그라운드 프로세스(foreground process)**: 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- **백그라운드 프로세스(background process)**: 사용자가 볼 수 없는 공간에서 실행되는 프로세스
  - 백그라운드 프로세스에는 사용자와 상호작용이 가능한 프로세스와 그렇지 않고 정해진 일만 수행하는 프로세스가 있는데, 이중 후자를 데몬(demon, 유닉스) 혹은 서비스(service, 윈도우)라고 한다.

### 프로세스 제어 블록(PCB)

- CPU자원은 한정되어 있기 때문에 프로세스들은 돌아가며 한정된 시간만큼만 CPU를 이용한다.
- 타이며 인터럽트(타임아웃 인터럽트)가 발생하여 시간을 끝났음을 알리면 차례를 양보한다.
- **프로세스 제어 블록(PCB)**: 빠르게 번갈아가며 수행되는 프로세스들을 관리하기 위해 사용하는 자료구조로 프로세스에 있어 태그, 꼬리표같은 존재이다.
- PCB에는 프로세스 관련 온갖 정보를 저장한다.
  - 프로세스 ID(PID)
  - 레지스터 값 → 이전의 작업을 이어 실행하기 위해 사용했던 레지스터의 중간값들을 모두 복원
    - 프로그램 카운터(프로세스가 다음에 실행할 명령어의 주소)
    - CPU 레지스터
    - (**레지스터 값**이란 CPU의 레지스터에 저장되어 있는 데이터를 의미한다. **레지스터**는 컴퓨터의 중앙 처리 장치(CPU) 내부에 위치하며, 매우 빠르게 접근할 수 있는 작은 메모리 단위이다. CPU는 이 레지스터들을 사용하여 명령어를 실행하는 동안 필요한 데이터를 빠르게 읽고 쓴다.)
  - 프로세스 상태
  - CPU 스케줄링 정보 → 어떤 프로세스를 먼저, 얼마나 오래 실행할지
  - 메모리 정보
  - 사용한 파일과 입출력 장치 정보
- 프로세스 생성시 커널 영역에 PCB를 생성하고, 종료시 폐기한다.

### 문맥 교환(context switch)

- 한 프로세스에서 다른 프로세스로 실행 순서가 넘어가면 기존에 실행되던 프로세스는 중간 정보들을 백업해야 한다.
- **문맥(Context)**: 다음 차례가 왔을 때 실행을 재개하기 위한 정보
  - 프로그램 카운터 등 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력 장치 등
- **문맥 교환(Context switching)**: 프로세스 전환시 기존에 실행중인 프로세스의 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정

### 프로세스의 메모리 영역

- 메모리의 사용자 영역은 다음 영역들과 기타 영역들로 나뉜다.
- 일반적으로 커널은 가장 높은 주소에 할당되어 있고 그 다음 순서는 다음과 같다.

1. **스택 영역(stack segment)**
   - 데이터가 일시적으로 저장되는 공간
   - 매개 변수, 지역 변수
   - 크기가 변하는 동적 할당 영역
2. **힙 영역(heap segment)**
   - 프로그래머가 직접 할당할 수 있는 저장 공간
   - **가비지 컬렉션(Garbage Collection)**: 프로그래밍 언어가 할당된 메모리 공간을 알아서 반환
   - **메모리 누수(memory leak)**: 할당된 메모리 영역을 반환하지 않아 생기는 메모리 낭비(C언어)
   - 크기가 변하는 동적 할당 영역
3. **데이터 영역(data segment)**
   - 프로그램이 실행되는 동안 유지할 데이터 저장
   - 전역 변수
   - 크기가 고정된 정적 할당 영역
4. **코드 영역(code segment)**
   - 텍스트 영역이라고도 한다.
   - 실행할 수 있는 코드, 기계어로 이루어진 명령어를 저장한다.
   - CPU가 실행할 명령어가 담긴 공간으로 쓰기가 금지되어 있다.
   - 크기가 고정된 정적 할당 영역

- 가변적인 스택 영역과 힙 영역에서
  - 일반적으로 스택 영역은 높은 주소에서 낮은 주소로 할당되며
  - 일반적으로 힙 영역은 낮은 주소에서 높은 주소로 할당된다.

### 프로세스 상태와 계층 구조

- 프로세스에는 저마다의 상태가 있는데, 운영체제마다 조금씩 다르지만 일반적으로 다음 5가지가 있다.

1. **생성 상태**: 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
2. **준비 상태**: 당장 CPU를 할당받아 실행할 수 있지만 자신의 차례가 아니라서 대기중인 상태
3. **실행 상태**: CPU를 할당 받아 실행중인 상태
4. **대기 상태**: 실행중 입출력장치를 사용하면 입출력 작업 종료시까지 대기 상태, 이후 준비 상태
5. **종료 상태**: 프로세스가 종료되어 PCB와 프로세스의 메모리 영역 정리

- 윈도우 운영체제는 프로세스를 계층적으로 관리하지 않지만 대부분의 운영체제는 계층 구조를 가진다.
- 프로세스 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다.
- 이때 새 프로세스를 생성한 프로세스가 **부모 프로세스**, 생성된 프로세스가 **자식 프로세스**이다.
- 부모 프로세스(Parent Process)와 자식 프로세스(child process)는 각기 다른 PID를 가진다.
- 리눅스에서 최초의 프로세스는 `systemd`, macOS에서는 `launchd`이다.

### 프로세스 생성 기법

- 부모 프로세스는 **fork 시스템 호출**을 통해 자신의 복사본을 자식 프로세스로 생성
- 자식 프로세스는 **exec 시스템 호출**을 통해 자신의 메모리 공간을 다른 프로그램으로 교체

## 스레드

- **스레드(thread)**: 실행 프로세스를 구성하는 실행 흐름의 단위
  - 스레드 ID, 프로그램 카운터를 포함한 레지스터 갑스 스택 등으로 구성
  - 실행에 필요한 최소한의 정보를 유지한 채 실행된다.
  - 모든 스레드는 프로세스의 자원을 공유하며 실행
- 하나의 프로세스는 하나 이상의 스레드를 가질 수 있다.
- **멀티 스레드 프로세스**: 실행 흐름이 여러개인 프로세스
  - 프로세스를 이루는 여러 명령어 동시 실행 가능
- 리눅스에서는 프로세스와 스레드를 구분하지 않고 태스크라고 표현한다.

## 멀티 프로세스와 멀티 스레드

- 단일 스레드 프로세스 여러개 실행 vs 하나의 프로세스를 여러 스레드로 실행

1. 멀티 프로세스

   - 프로세스를 fork하면 메모리 주소를 제외한 모든 것이 동일한 프로세스가 복제되어 저장된다.
   - 프로세스끼리 자원을 공유하지는 않는다.
   - 독립적으로 실행된다.
   - 프로세스 간 통신(IPC, InterProcess Communication)으로 프로세스 간에도 자원을 주고 받을 수 있다.
   - 파일, 메모리를 통한 프로세스 간 통신

2. 멀티 스레드

   - 자원을 공유한다
   - 협력과 통신에 유리하다.
