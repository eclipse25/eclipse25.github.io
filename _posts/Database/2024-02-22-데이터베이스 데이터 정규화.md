---
layout: post
title: "데이터베이스 데이터 정규화"
categories: [Database]
tags: [Data, Database]
---

## 데이터 정규화

- 데이터베이스 설계의 핵심 과정 중 하나
- 중복을 최소화하고 데이터 무결성을 유지하기 위해 데이터를 구조화하는 방법이다.
- 데이터의 복잡성을 줄이고 논리적인 구조를 개선하는 것을 목표로 한다.
- 이 과정을 통해 데이터베이스의 성능을 향상시킬 수 있다.
- 그러나 너무 많은 정규화는 성능 저하를 초래할 수 있으므로, 실제 응용 프로그램의 요구 사항과 트레이드오프를 고려해서 적절한 수준의 정규화를 결정해야 한다.

### 정규화의 필요성

- 중복 제거: 중복된 데이터는 저장 공간을 낭비하게 하고 데이터 갱신 시 일관성 유지에 문제를 일으킬 수 있다.
- 데이터 무결성 보장: 데이터 간의 일관성과 정확성을 유지한다.
- 갱신 이상 방지: 데이터를 추가, 삭제, 수정할 때 발생할 수 있는 예상치 못한 문제들을 방지한다.

### 정규화 과정(정규형) 요약

정규화는 여러 단계의 '정규형'을 통해 이루어진다. 각 정규형은 이전 단계보다 더 엄격한 조건을 충족해야 하며, 일반적으로 다음과 같은 순서를 따른다.

1. **1차 정규형 (1NF)**: 모든 테이블의 칼럼 값이 원자값(분할 불가능한 값)이어야 한다. 즉, 각 필드에는 반복되는 그룹이나 배열 등이 없어야 한다.
2. **2차 정규형 (2NF)**: 1NF를 만족하며, 모든 비키 속성이 기본 키에 완전 함수적으로 종속되어야 한다. 즉, 부분적 종속을 제거한다.
3. **3차 정규형 (3NF)**: 2NF를 만족하며, 모든 비키 속성이 기본 키에 대해 이행적으로 종속되지 않아야 한다. 이행적 종속성을 제거하여 비키 속성 간의 종속성을 방지한다.
4. **보이스/코드 정규형 (BCNF)**: 3NF를 만족하며, 모든 결정자가 후보 키가 되도록 한다. 이는 3NF보다 더 엄격한 조건으로, 결정자가 후보 키가 아닌 경우를 해결한다.
5. **4차 정규형 (4NF)**: BCNF를 만족하며, 모든 다중값 종속성을 제거한다. 특정 속성이 다른 속성에 대해 두 개 이상의 독립적인 값을 가지는 경우를 해결한다.
6. **5차 정규형 (5NF)**: 모든 조인 종속성이 후보 키를 통해서만 만족되는 구조이다. 분해하여도 원래의 정보를 잃지 않는 최적의 정규형이다.

## 주요 정규형들

### **1차 정규형(1NF)**

- 테이블의 모든 필드가 원자값(더 이상 나눌 수 없는 값)만을 포함하도록 한다.
- 각 칼럼에는 반복되는 그룹이나 배열을 사용할 수 없으며, 각 필드는 단일 값만을 가져야 한다.

- 1NF를 만족하지 않는 예시

  | Student Name | Courses Enrolled      |
  | ------------ | --------------------- |
  | John Doe     | Math, Science         |
  | Jane Smith   | History, English, Art |

  - 각 학생의 등록된 과목이 하나의 셀에 쉼표로 구분되어 나열되어 있어 1NF를 만족하지 않는다.

- 1NF를 만족하는 예시

  | Student Name | Courses Enrolled |
  | ------------ | ---------------- |
  | John Doe     | Math             |
  | John Doe     | Science          |
  | Jane Smith   | History          |
  | Jane Smith   | English          |
  | Jane Smith   | Art              |

  각 과목이 별도의 행으로 분리되어, 모든 셀이 원자값만을 포함하도록 조정되어 1NF를 만족한다.

### **2차 정규형(2NF)**

- 1NF를 만족하며, 모든 비주요 칼럼이 기본 키에 완전 함수적으로 종속되어야 한다.
- 부분적 종속성을 제거하여 각 칼럼이 기본 키에만 종속되도록 한다.
- 기본키가 아닌 모든 속성이 **기본키에 완전 함수 종속된 상태**이다.
- 기본 키 이외의 속성에 대한 종속성을 제거하여 데이터 중복을 더 줄인다.

- 2NF를 만족하지 않는 예시

  | Student ID | Course ID | Course Name |
  | ---------- | --------- | ----------- |
  | 1          | 101       | Mathematics |
  | 1          | 102       | English     |
  | 2          | 101       | Mathematics |
  | 2          | 103       | History     |

  과정 이름(Course Name)이 과정 ID에 부분적으로 종속되어 있기 때문에 2NF를 만족하지 않는다.

- 2NF를 만족하는 예시

  StudentCourses와 Courses 두 개의 테이블로 분할할 수 있다.

  **StudentCourses** 테이블:

  | Student ID | Course ID |
  | ---------- | --------- |
  | 1          | 101       |
  | 1          | 102       |
  | 2          | 101       |
  | 2          | 103       |

  **Courses** 테이블:

  | Course ID | Course Name |
  | --------- | ----------- |
  | 101       | Mathematics |
  | 102       | English     |
  | 103       | History     |

  StudentCourses 테이블은 학생 ID와 과정 ID만 포함하여 기본 키에 완전히 함수적으로 종속된다.

  Courses 테이블은 과정 ID와 과정 이름을 포함하여 과정 이름이 과정 ID에 완전히 종속된다.

  이렇게 분할함으로써, 각 테이블은 2NF를 만족하게 된다.

### **3차 정규형(3NF)**

- 정의: 2NF를 만족하며, 모든 비주요 칼럼이 기본 키에 대해 이행적으로 종속되지 않아야 한다.
- 비주요 칼럼 간의 종속성을 제거한다.
- 데이터 간의 이행적 종속성을 제거하여 데이터 무결성을 더욱 강화한다.
- **이행적 종속성**(Transitive Dependency)

  - 한 속성이 다른 속성에 **간접적으로 종속**되는 관계를 의미한다.
  - 예를 들어, A, B, C 세 속성이 있을 때, **A가 B에 종속**되고 **B가 C에 종속**되는 경우, **A는 C에 이행적으로 종속**된다고 한다.

- 3NF를 만족하지 않는 예시

  | Student ID | Student Name | Department Name  | Department Head |
  | ---------- | ------------ | ---------------- | --------------- |
  | 1          | John Doe     | Computer Science | Dr. Smith       |
  | 2          | Jane Smith   | Mathematics      | Dr. Johnson     |

  이 테이블에서 Student ID → Department Name → Department Head로 이행적 종속성이 있다.

- 3NF를 만족하는 예시

  위의 테이블을 학생 테이블과 학과 테이블로 나눈다.

  학생 테이블(Student Table):

  | Student ID | Student Name | Department Name  |
  | ---------- | ------------ | ---------------- |
  | 1          | John Doe     | Computer Science |
  | 2          | Jane Smith   | Mathematics      |

  학과 테이블(Department Table):

  | Department Name  | Department Head |
  | ---------------- | --------------- |
  | Computer Science | Dr. Smith       |
  | Mathematics      | Dr. Johnson     |

  3NF 정규화 과정을 통해, 이행적 종속성을 제거하여 두 개의 테이블로 분리한다.이로써 각 테이블은 더 이상 이행적으로 종속된 속성을 포함하지 않으며 3NF의 요구사항을 만족한다.

### **보이스/코드 정규형(BCNF)**

- Raymond F. Boyce와 Edgar F. Codd. Edgar F. Codd가 제안했다.
- 3NF를 만족(모든 칼럼이 **완전 함수적 종속성** 만족)하며, 모든 결정자가 후보 키가 되도록 한다.

  - **복합키 (Composite Key)**

    복합키는 두 개 이상의 칼럼으로 구성된 키로, 이 칼럼들의 조합이 테이블 내의 각 행을 유일하게 식별한다. 복합키의 각 구성 요소는 자체적으로는 행을 유일하게 식별하지 못할 수도 있지만, 조합될 때 유일한 식별자 역할을 한다. 예를 들어, 한 과목을 여러 교수가 가르칠 수 있다면, CourseID와 InstructorID의 조합이 복합키가 될 수 있다.

  - **후보키 (Candidate Key)**

    후보키는 테이블 내의 각 행을 유일하게 식별할 수 있는 속성(들)의 집합이다. 후보키는 **유일성(uniqueness)**과 **최소성(minimality)**을 만족해야 한다. 유일성은 후보키가 테이블의 모든 행을 유일하게 식별할 수 있어야 한다는 것을 의미하며, 최소성은 후보키를 구성하는 속성 중 불필요한 속성 없이 최소한의 속성만으로 구성되어야 한다는 것을 의미한다. 후보키 중에서 선택된 하나는 기본키(Primary Key)로 사용된다.

  - **결정자 (Determinant)**

    결정자는 한 속성 집합의 값이 다른 속성 집합의 값을 결정할 수 있는 속성 또는 속성 집합을 의미한다. 예를 들어, CourseID가 RoomNumber를 결정한다면, CourseID는 결정자이다.

  - **모든 결정자가 후보 키인 상태**

    BCNF(보이스/코드 정규형)에서는 테이블의 모든 결정자가 후보 키여야 한다. 즉, 테이블 내에서 어떤 속성의 값이 다른 속성의 값을 결정(함수적 종속)한다면, 그 결정자는 반드시 후보 키의 일부여야 한다. 이는 데이터 중복을 최소화하고, 데이터 무결성을 보장하기 위한 조건이다. BCNF는 테이블이 더 엄격한 정규화 기준을 충족하도록 요구하여, 갱신 이상(update anomalies)을 방지하고 데이터 무결성을 유지하도록 한다.

- BCNF를 위반하는 예시

  다음 테이블에는 강의 코드(LectureCode), 강사 이름(Instructor), 그리고 강의가 열리는 요일(Day)이 포함되어 있다. 강의 코드와 강사 이름이 함께 복합 키를 형성하고, 강의 코드가 요일을 결정한다.

  강의 스케줄 테이블:

  | LectureCode | Instructor | Day       |
  | ----------- | ---------- | --------- |
  | CSE101      | Dr. Smith  | Monday    |
  | CSE101      | Dr. Jones  | Wednesday |
  | MTH101      | Dr. Lee    | Tuesday   |

  이 테이블은 BCNF를 만족하지 않는다. 문제는 LectureCode가 Day를 결정한다는 것인데, LectureCode는 복합 키의 일부이지만 Day를 결정하는 결정자가 된다. 그렇지만 LectureCode는 후보 키가 아니고, BCNF에서는 모든 결정자가 후보 키의 일부이어야 하므로, 이 테이블은 BCNF 조건을 위반한다.

- BCNF를 만족시키는 정규화 예시

  테이블을 두 개로 분리할 수 있다.

  강의 정보 테이블:

  | LectureCode | Day       |
  | ----------- | --------- |
  | CSE101      | Monday    |
  | CSE101      | Wednesday |
  | MTH101      | Tuesday   |

  강의 강사 테이블:

  | LectureCode | Instructor |
  | ----------- | ---------- |
  | CSE101      | Dr. Smith  |
  | CSE101      | Dr. Jones  |
  | MTH101      | Dr. Lee    |

  이렇게 분리하면, 강의 정보 테이블은 LectureCode에 의해 Day가 결정되고 모든 결정자(LectureCode)가 후보 키이다. 강의 강사 테이블은 LectureCode와 Instructor의 복합 키를 유지하고, 각각의 테이블이 BCNF를 만족하게 된다.

### **4차 정규형(4NF)**

- BCNF를 만족하고, 다중값 종속성(MVD)이 없어야 한다.

  - **다중값 종속성(MVD)**
    다중값 종속성은 한 속성(A)이 다른 속성(B)에 대해 여러 값을 결정할 수 있을 때 발생한다. 이는 A가 B를 결정할 때, B의 값이 A의 값에만 의존하며, 테이블의 다른 속성과는 독립적인 여러 값을 가질 수 있다는 것이다.

- 4NF를 만족하지 않는 예시

학생 취미 및 언어 테이블:

| StudentID | Course  | PreferredBooks                           |
| --------- | ------- | ---------------------------------------- |
| 1         | Math    | "Algebra", "Calculus"                    |
| 1         | Physics | "Classical Mechanics", "Quantum Physics" |
| 2         | Math    | "Algebra", "Calculus"                    |

학생들은 여러 취미와 여러 언어를 가질 수 있는데, 이 테이블은 StudentID와 Course에 대한 다중값 종속성이 PreferredBooks에 존재(한 학생이 같은 과목에 대해 여러 교재를 선호할 수 있음)하여 4NF를 위반한다.

- 4NF를 만족하는 테이블 구조로 분리

  학생-과목 테이블

  | StudentID | Course  |
  | --------- | ------- |
  | 1         | Math    |
  | 1         | Physics |
  | 2         | Math    |

  과목-선호 교재 테이블

  | Course  | PreferredBook       |
  | ------- | ------------------- |
  | Math    | Algebra             |
  | Math    | Calculus            |
  | Physics | Classical Mechanics |
  | Physics | Quantum Physics     |

  분리한 두 테이블은 각각 학생-과목 관계와 과목별 선호 교재를 명확하게 나타낸다. 이렇게 테이블을 분리하면 데이터의 중복을 줄이고 각 관계를 더 명확하게 표현함으로써 4NF를 만족한다.

### **5차 정규형(5NF)**

- 5차 정규형(5NF) 또는 프로젝션-조인 정규형(Project-Join Normal Form, PJNF)은 관계형 데이터베이스의 정규화 과정에서 가장 높은 수준의 정규형 중 하나이다.
- 테이블이 5NF를 만족한다는 것은 4NF를 만족하며, **모든 조인 종속성이 후보 키를 통해서만 만족**되도록 한다. 즉, 어떤 테이블도 분해하여 재조합할 때 정보 손실이 없어야 한다.
- 복잡한 조인 관계에서도 데이터의 일관성과 무결성을 유지한다.

- 5NF를 만족하지 않는 예시

  **학생**이 여러 **과목**을 수강하며, 각 **과목**은 여러 **교실**에서 강의될 수 있고, 각 **학생**은 특정 **과목**에 대해 특정 **교실**을 선호할 수 있다.

  | Student | Course  | Classroom |
  | ------- | ------- | --------- |
  | Alice   | Math    | A101      |
  | Bob     | Math    | A102      |
  | Alice   | Science | B201      |
  | Bob     | Science | B202      |

  이 테이블 구조에서는 **학생**과 **과목** 사이, **과목**과 **교실** 사이, 그리고 **학생**과 **교실** 사이의 관계가 명확하게 표현되지 않아, 데이터를 분해하고 다시 조인할 때 원하지 않는 조합이 발생할 수 있다.

- 5NF를 만족하는 테이블로 분해

  학생-과목 테이블:

  | Student | Course  |
  | ------- | ------- |
  | Alice   | Math    |
  | Bob     | Math    |
  | Alice   | Science |
  | Bob     | Science |

  과목-교실 테이블:

  | Course  | Classroom |
  | ------- | --------- |
  | Math    | A101      |
  | Math    | A102      |
  | Science | B201      |
  | Science | B202      |

  학생-선호 교실 테이블:

  | Student | Classroom |
  | ------- | --------- |
  | Alice   | A101      |
  | Bob     | A102      |
  | Alice   | B201      |
  | Bob     | B202      |

  이렇게 분해하면 각 테이블은 더 명확하고 단순한 관계를 나타내며, 모든 조인 종속성이 후보 키를 통해서만 만족된다. 따라서 이 구조는 5NF를 만족하는데, 데이터를 분해하고 다시 조인해도 원래의 정보를 잃지 않으며, 불필요한 데이터 중복이나 무결성 문제를 방지할 수 있다!
