---
layout: post
title: "[Network] 네트워크 계층(Network Layer) - IP"
categories: [Network]
tags: [Network]
---

OSI 7계층에서 **Network Layer**은 IP 프로토콜, 라우팅 알고리즘, ICMP 프로토콜을 다룬다

- **패킷 (Packet)**: "패킷"은 데이터를 라우팅 및 전송하는 데 사용되는 작은 데이터 덩어리(단위). 송신지에서 목적지로 전송되며, 주소, 제어 정보 및 페이로드 데이터를 포함
- **데이터그램 (Datagram)**: 일반적으로 데이터를 분할한 패킷. 일반적으로 데이터그램은 비연결형 통신에 사용됨. UDP(사용자 데이터그램 프로토콜)는 데이터그램 방식의 프로토콜

<img src="https://github.com/eclipse25/eclipse25.github.io/assets/109349939/2acb10a1-ff2d-4a64-a9dd-2b64c757d23d" alt="IP" width="400"/>

**IP(the Internet Protocol)**

컴퓨터 네트워크에서 데이터 패킷을 라우팅하고 전송하는 데 사용되는 프로토콜

인터넷을 비롯한 다양한 네트워크에서 통신 관리, 주소 지정

"통합"에 중요한 역할을 하며 어느곳이나 이식할 수 있어 생산성이 좋다.

주소의 가상화는 편하지만 대신에 실시간성(정확히 얼마의 시간이 걸리는지의 정보)을 잃는다.

• datagram format

• addressing

• network address translation

• IPv6

**IP Datagram format**

<img src="https://github.com/eclipse25/eclipse25.github.io/assets/109349939/390ce006-8808-4f08-b65e-bf510d139b42" alt="IPv4" width="800"/>

- ver부터 options까지 헤더, payload data가 전하려는 내용
- **헤더(IPv4)** : 라우팅 및 패킷 전송에 사용되는 정보
  - **ver** - IP 프로토콜의 버전. IPv4의 경우 "0100" 또는 "4"
  - **header length** - 헤더의 길이. 4바이트 단위로 표현
  - **type of service** - 서비스 품질에 대한 정보. 트래픽의 우선 순위, 서비스 유형 및 기타 정보
  - **length** - 전체 패킷 길이. 헤더와 페이로드의 길이를 합한 값으로, 바이트 단위로 표현
  - **16-bit identifier** - 패킷의 고유한 식별자로, 패킷(데이터그램)을 자른 후 재조립 및 다른 기능을 위해 사용
  - **flgs** - 패킷 분할과 관련된 플래그. 패킷이 분할되어 전송되는 경우 해당 플래그를 사용, 보통 3bits
    - 비트 0 (**MF**, More Fragments): 가장 마지막 비트로, 설정되면 이 데이터그램은 더 연결될 단편이 있음
    - 비트 1 (DF, Don't Fragment): 이 비트가 설정되면, 데이터그램은 단편화되어서는 안 됨
    - 비트 2 (Reserved): 예약된 비트로 현재는 사용되지 않음
  - **fragment offset** - 분할된 패킷의 오프셋. 분할된 패킷을 원래 패킷으로 다시 조립할 때 사용. 시작점으로부터 상대적 위치를 써서 합칠 때 편하게 됨
  - **time to live(TTL)** - 패킷이 라우팅되는 동안 남은 수명. 패킷이 무한 루프에 빠지지 않도록 방지하는 데 사용. 8bits고 라우터를 255번까지 지나가게 할 수 있지만 보통 16번 정도로 설정한다.
  - **upper layer** - 상위 계층 프로토콜. 이 필드는 패킷이 상위 계층 (예: TCP, UDP)으로 어떤 데이터를 전달해야 하는지를 결정하는 데 사용
  - **header checksum** - 헤더의 무결성을 검사하기 위한 값으로 0, 1이 바뀌는 에러를 잡는다. IPv6에서는 사라짐
  - **source IP address** - 출발지 IP 주소로, 패킷의 송신자를 식별
  - **destination IP address** - 목적지 IP 주소로, 패킷의 수신자 식별
  - **options** - 선택적인 헤더 필드. 일반적으로 사용되지 않고 특별한 요구 사항이 있는 경우에만 포함
- **페이로드(Payload) :** 데이터 패킷 내에서 실제 데이터로, 패킷의 본문 또는 내용, 즉 알맹이
- identifier는 데이터의 사이즈가 커서 링크를 지나가지 못할 때 여러 조각으로 자르고 다시 합치기 위해 필요
- **MTU(Maximum Transfer Unit)**

  - 네트워크에서 전송 가능한 최대 데이터 패킷 크기, IP 헤더 20bytes 포함
  - MTU의 크기는 데이터 링크 계층에서 결정됨
  - IP 헤더와 함께 전송되는 패킷의 크기가 MTU보다 작아야 해당 패킷이 전송되고 단편화가 발생하지 않음
  - 일반적으로 사용되는 이더넷 MTU는 1500 bytes
  - 이더넷 1500 바이트 MTU에서 IP 헤더(일반적으로 20bytes)를 포함한 패킷의 최대 크기는 1480 bytes

- IP header(20) + TCP header(20)  = 40bytes
- flgs + fragment offset = 16bits

**IP Address**

- **IP 주소**는 네트워크 주소 부분과 호스트(라우터 인터페이스) 주소 부분으로 나뉜다.
- IPv4는 32비트의 IP 주소 사용(IPv6는 128비트) → 2^32개의 node를 묶을 수 있다.
- 32-bit를 8-bit씩 4부분으로 나눈다. 마지막 8bit 혹은 16bit가 호스트 주소가 되고 앞부분이 네트워크 주소
- 서브넷 마스크
  - CIDR 표기법으로 /24인 경우 24비트가 네트워크 주소, 남은 8비트가 호스트 주소를 나타냄
  - CIDR 표기법에서 /16인 경우 16비트가 네트워크 주소, 남은 16비트가 호스트 주소를 나타냄
  - 예시 - 192.168.10.0/24 네트워크가 가질 수 있는 최대 호스트 수는 254개 (2^8-2)
- **인터페이스(Interface)**는 호스트(컴퓨터 또는 장치), 라우터, 스위치 등과 물리적인 네트워크 링크를 연결
- 라우터는 일반적으로 LAN, WAN, VLAN 등 여러 인터페이스를 가진다.
- 호스트는 일반적으로 1개, 2개의 인터페이스를 가진다.
- 이러한 주소체계는 하나의 큰 범위 내에서 좁혀가면서 길을 찾기 편하다.

**Subnets(서브넷)**

- IP 네트워크를 더 작은 논리적인 네트워크로 분할한 것
- network ID를 공유
- 찾아가기 편하지만 그 지역에 묶임
- 32bits IP주소 앞부분이 subnet주소, 뒷부분이 host주소

**CIDR (Classless Inter-Domain Routing)**

- 네트워크 마스크를 슬래시("/")로 구분하여 표기.
- IP 주소가 "192.168.1.0/24"이면, 24비트의 서브넷 마스크
- 서브넷 마스크의 길이가 가변적으로 조절되어 네트워크를 필요에 따라 더 작게 또는 더 크게 나눌 수 있음
- 기존의 A, B, C 클래스와 관련된 고정된 주소 범위 할당 제한을 해제, 더 자유롭게 주소 할당
  - 32bits IP주소 앞부분이 subnet주소, 뒷부분이 host주소 → host 주소 bit수가 많을수록 연결 기기 수 증가
  - Class A - 8bit가 subnet주소, 24bit가 host주소 → 최대 호스트 수는 16777214개 (2^32-2)
  - Class B - 16bit가 subnet주소, 16bit가 host주소 → 최대 호스트 수는 65534개 (2^16-2)
  - Class C - 24bit가 subnet주소, 8bit가 host주소 → 최대 호스트 수는 254개 (2^8-2)
  - 호스트주소가 0으로만 이루어지면 (ex. class C에서 00000000)는 네트워크 주소, 1로만 이루어지면 (ex. class C에서  11111111) broadcast를 나타냄. 따라서 2를 빼줌

**DHCP(Dynamic Host Configuration Protocol)**

- 동적 IP 할당, 임시 IP주소를 통해 장치가 네트워크에 연결 및 해제할 때 자동으로 IP 주소를 할당하고 해제
- 네트워크에 연결되는 컴퓨터나 장치에 자동으로 IP 주소를 할당, 주소 충돌 방지

**네트워크통신 전송 방식**

- Unicast (유니캐스트):
  - 가장 일반적인 통신 방식으로, 한 송신자가 한 수신자에게 데이터를 보내는 방식
  - 웹 서버가 클라이언트에게 웹 페이지를 제공하거나 이메일 서버가 이메일을 특정 수신자에게 전달하는 경우
- Multicast (멀티캐스트):
  - 한 송신자가 여러 수신자 그룹에게 데이터를 보내는 방식
  - 그룹은 동일한 데이터에 관심이 있는 여러 수신자로 구성
  - 인터넷 Protocol (IP) 네트워크에서 IPTV, 인터넷 방송, 그룹 채팅 및 멀티미디어 스트리밍과 같은 다중 수신자 서비스에서 사용
  - 무한루프를 돌며 Multicast Storm이 일어나는 것을 막기 위해 루프를 만들지 않음, 트리구조
  - 진행하다가 한 번 끊어지면 서브트리로의 신호가 다 끊어짐
- Broadcast (브로드캐스트):
  - 한 송신자가 네트워크 내 모든 수신자에게 데이터를 보내는 방식
  - 전체 네트워크를 대상으로 데이터를 전송
  - 이더넷 네트워크에서 사용되며, 특정 네트워크 주소(예: 255.255.255.255)를 사용하여 모든 호스트에게 데이터를 전송, 전체 트래픽에 영향을 미칠 수 있으므로 현대 네트워크에서는 제한적으로 사용

**NAT (Network Address Translation)**

- 네트워크에서 주소 변환을 수행하는 기술
- 내부 네트워크와 외부 네트워크 간의 통신을 관리하고 보안을 강화하기 위해 사용
- 10으로 시작하는 주소 - 로컬영역에서만 쓸 수 있음
- 라우터 또는 방화벽 장치에서 구현
- 기능
  - 내부 네트워크의 개별 장치가 외부 네트워크와 통신할 때 내부 IP 주소를 외부 IP 주소로 변환
  - 내부 장치에 대해 임시 내부 IP 주소를 동적으로 할당하거나 정적으로 매핑
  - 여러 장치가 동일한 외부 IP 주소를 공유하는 경우, 각 장치의 트래픽을 고유한 포트 번호로 매핑하여 서로를 구분
  - 내부 장치의 IP 주소를 외부에서 숨김으로써 내부 네트워크의 보안 강화
  - 내부 네트워크에서 사설 IP 주소를 사용하고 NAT를 통해 외부 네트워크와 통신함으로써 IP 주소 고갈 문제 완화
- IP주소 + 포트넘버(16bits)를 붙여서 IP 부족 문제를 해결함으로써 IPv6 도입을 늦어지게 하기도 했다.
- 장점
  - 내부 네트워크가 옮겨가더라도 router에 직접 연결되는 주소만 바꾸면 되기 때문에 이식성이 좋음
  - 보안상 안전
- 단점
  - Layer3 문제를 Layer4에서 해결했다는 비판
  - end-to-end연결을 불가능하게 해서 인터넷 프로토콜의 핵심 아이디어를 violate
  - 고유한 IP가 없어 webserver역할이 어렵다 → 위탁 필요
  - UDP 트래픽 문제

**IPv6**

- 모바일 발전으로 많이 보급됨
- motivation - IPv4의 할당 완료(고갈), IPv4의 문제점 극복
- IPv5는 멀티미디어 스트림으로 실험적 개발, 어느 순간 없어짐
- IP 주소 길이는 128bits
- datagram format
  - ver - IP 프로토콜의 버전. IPv6의 경우 6
  - priority - 패킷 유형의 우선순위
  - flow label - 패킷의 흐름을 식별하는 데 사용하지만 사실 flow의 개념도 잘 정립되지 않았음
  - payload len - IPv6 헤더의 끝에서 실제 데이터 패킷(페이로드)의 시작까지의 길이를 byte로 표시
  - next hdr - 다음 헤더의 종류 또는 페이로드 데이터의 유형
  - hop limit - 라우터를 거치는 횟수를 제한하는 값으로  TTL에 대응되는 개념
  - source address - 송신자의 IPv6 주소
  - destination address - 송신자의 IPv6 주소
  - payload - 전달하려는 data 내용
- flow label, priority는 오늘날 전혀 쓰이지 않는다. 경로를 예측할 수 없기 때문에 flow를 support할 수 없음
- IPv4와 비교했을 때 checksum, option이 없어짐
- IPv4에서 IPv6으로 바뀌면서 전세계의 IPv4 라우터를 바꿔야하는 문제가 생김
- IPv6의 패킷이 IPv4 영역을 지나갈 때는 IPv4 헤더를 겉에 붙이는 Tunneling으로 해결, hop limit는 이때 줄어들지 않음

<img src="https://github.com/eclipse25/eclipse25.github.io/assets/109349939/eba5588a-6671-4d12-9984-b2a81454983c" alt="IPv6" width="800"/>

---

**네트워크가 고속화되면서 Identifier가 문제가 되는 이유**

고속화되면서 같은 Identifier를 갖는 서 로 다른 데이터그램이 동시에 인터넷에 존재 할 수 있음

(Wrap-around 문제, 0에서 65535 까지 빠르게 증가하면 다시 0이 나타남)

**header length가 20보다 크다면 그 이유**

옵션의 존재

**length가 5000 byte인 데이터그램이 MTU가 1500인 링크를 만났을 때 생성되는 마지막 fragment의 offset과 length**

\- 첫 번째 프래그먼트:

오프셋(offset): 0

길이(length): MTU(1500) - IPv4 헤더(20) = 1480 바이트

\- 두 번째 프래그먼트:

오프셋(offset): 이전 프래그먼트의 오프셋(0) + 이전 프래그먼트의 길이(1480) = 1480

길이(length): MTU(1500) - IPv4 헤더(20) = 1480 바이트

\- 세 번째 프래그먼트:

오프셋(offset): 이전 프래그먼트의 오프셋(1480) + 이전 프래그먼트의 길이(1480) = 2960

길이(length): MTU(1500) - IPv4 헤더(20) = 1480 바이트

\- 네 번째(마지막) 프래그먼트:

오프셋(offset): 이전 프래그먼트의 오프셋(2960) + 이전 프래그먼트의 길이(1480) = 4440

길이(length): 남은 데이터 길이 (5000 - 4440 = 560 바이트)

따라서, 마지막 프래그먼트의 오프셋(offset)은 4440이며, 길이(length)는 560 바이트

---

Computer Networking: A Top-Down Approach 8 th edition Jim Kurose, Keith Ross Pearson, 2020
